@inject ASP_SPD_111.Services.Hash.IHashService hashService
@{
    ViewData["Title"] = "Ioc";
}

<h1 class="display-4">Інверсія управління</h1>
<p>
    Інверсія управління (IoC, Inversion of Control) - схема побудови
    архітектури проєкту, за якої управління життєвим циклом об'єктів
    делегується окремому модулю. Життєвий цикл - CRUD - створення,
    впровадження, модифікація, видалення.
    Ідея полягає у тому, що спочатку відбувається реєстрація служб - 
    провайдерів об'єктів. На другому етапі відбувається розв'язування
    (Resolve) залежностей, тобто побудова об'єкту з усіма заявленими
    залежностями від інших об'єктів (служб, сервісів).
</p>
<p>
    DIP (Dependency Inversion Principle) - принцип інверсії залежностей
    (не плутати з IoC) - один з принципів SOLID, який пропонує
    створювати залежності не від конкретних типів, а від інтерфейсів.
    Це дозволяє легко замінити один тип на інший, якщо вони реалізують
    один інтерфейс.
</p>
<p>
    На прикладі служби гешування.
</p>
<ul>
    <li>
        Сервіси є структурною частиною проєкту, більш того, часто мають
        універсальне значення (можуть бути перенесені до іншого проєкту).
        Відповідно для них створюється папка "Services" на найвищому рівні
    </li>
    <li>
        За рекомендаціями DIP/SOLID навіть одиночний сервіс-клас має 
        супроводжуватись інтерфейсом, тобто на один сервіс припадає
        декілька файлів-класів. Відповідно, кожен з сервісів також
        уміщують в окрему папку ("Hash"). У ній створюємо інтерфейс та
        клас.
    </li>
    <li>
        Реєструємо сервіс. У Program.cs знаходимо розділ до 
        <code>var app = builder.Build();</code>
        та додаємо інструкцію реєстрації <br/>
        <code>builder.Services.AddSingleton&lt;IHashService, Md5HashService>();</code>
        <br />
        Це можна уявити як: "Будуть запитувати IHashService - видати Md5HashService"
    </li>
    <li>
        Заявляємо залежності - у контролері створюємо поле типу IHashService
        (див. HomeController)
    </li>
    <li>
        Уявляємо задачу переходу на іншу схему гешування. Для цього
        <ul>
            <li>
                у папці /Services/Hash створюємо ще один клас, який реалізує
                той самий інтерфейс IHashService - Sha1HashService
            </li>
            <li>
                У Program.cs замінюємо інструкцію реєстрації з новим 
                класом <br/>
                <code>builder.Services.AddSingleton&lt;IHashService, Sha1HashService>();</code>
            </li>
            <li>
                Перезапускаємо проєкт, служба замінюється автоматично
            </li>
        </ul>
    </li>
</ul>
<h2>Scope - область "життя" сервісу.</h2>
<p>
    При реєстрації служби зазначається її scope - поведінка щодо повторних
    запитів на інжекцію. У ASP є три області:
    Singleton - незмінний об'єкт, усі точки інжекції отримують посилання
    на один і той самий об'єкт.
    Transient - "одноразовий", кожна точка отримує новий об'єкт.
    RequestScope (.AddScoped) - постійний протягом одного запиту, наступний
    запит - нове створення об'єкту (як час життя контролерів)
</p>
<p>
    hash = @ViewData["hash"]<br/>
    hashCode(controller) = @ViewData["objHash"] <br/>
    hashCode(view) = @(hashService.GetHashCode())
</p>